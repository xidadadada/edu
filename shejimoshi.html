<html>
<body>
    <script type="text/javascript" src="../edu/day.js">
</script>
<script type="text/javascript" src="../edu/ps.js">
</script>
<div class=“rich_media_area_primary” style="margin:0px auto; width:800px;">
                
                
<h2 class="rich_media_title" title="设计模式">设计模式</h2>
                <div class="rich_media_meta_list">
                    <!-- <span class="rich_media_meta meta_original_tag dn"></span>
                    <a class="rich_media_meta meta_enterprise_tag" href="javascript:;"><img src="http://mmbiz.qpic.cn/mmbiz_jpg/QpRnoicU4ABbjkE59REvAMSTDRgGT5j0fTEcSZzsgA55SXOX4ZACR1XplMUUAITz1ic3l4MDgOw1RF4ichVzNX6fQ/0?wx_fmt=jpeg"></a> -->
                    <em class="rich_media_meta rich_media_meta_text">2018-02-22</em>
                    <em class="rich_media_meta rich_media_meta_text"></em>
                    <span class="rich_media_meta rich_media_meta_link" title="请发送到手机查看完整效果">学习交流</span>
                </div>
                
                              
                <div class="rich_media_content">
                    
                    <p><span class="RichText CopyrightRichText-richText" itemprop="text"></span></p><p><br></p><p>开发时为了让各个模块可以独立，便于封装，引入了设计模式。但前提是你必须能够精准地预测需求变更的方向，可事实上大部分人是做不到的。因此我们必须避免过度设计，需要深入理解程序应用领域的相关知识，理解用户的真正需求，这样你对用户需求变更的预测才会更准确，避免使用设计模式封装一些根本不会发生的变化，从而避免使用的设计模式将来无法适应需求的新变化。</p><p><br></p><p>GoF的《设计模式》一书，主要讲了三个层面的内容: <br>1. 指出设计模式需要关注的四要素 "名称-问题-解决方案-效果“ ，并给出描述一套模式的格式模板。<br>2. 提出了面向对象开发中”针对接口编程优于针对实现编程”，”组合优于继承”的总体设计思路。由于父类实现的改动，会导致子类也必须得改变。而<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">组合的方式可以保持每个类的内聚性，让每个类专注实现一个任务。 类的层次会保持的很小，不会增长到一种无法管理的恐怖数量。</span>&nbsp;</p><p>3. 选取了23种常见设计模式作为例详细描述<br></p><p><br></p><p style="margin-bottom: 0.72em;color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;"><span style="font-weight: 600;font-synthesis: style;">一般来说，使用设计模式的必要性的程度是逐级递增的：应用程序(Application) &lt; 工具包/类库（ToolKit/Library） &lt; 框架(Framework)。</span></p><p><span style="font-weight: 600;font-synthesis: style;"><br></span></p><ul style="" class=" list-paddingleft-2"></ul><p>不要为了设计模式而去用。<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;font-weight: 600;font-synthesis: style;">设计模式不是软件设计的起点，而是终点。</span><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">模式其实早已存在并已经广泛使用，只不过没有被系统地加以归纳整理。如果你遵循某些原则，这些所谓的模式完全有可能自然而然地出现在代码中。因此，</span><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">设计模式虽然可以方便开发者进行交流，但不能作为鉴别是否具有开发能力的工具。</span><br></p><p><br></p><p>而且，不要离开语言去讨论和学习设计模式。</p><p><br></p><p>如果它能把类型像变量一样赋值并传来传去，很多创建型模式就没用了。<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;">比如它</span><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">的 typeof 操作符能得到 runtime type，那么 Prototype 模式就没用了。<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">如果类型能像变量一样赋值和传递，Factory method 模式就没用了。如果它</span></span><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;">有全局变量，Singleton 模式就没用了。Singleton 是最简单也最被滥用的模式。</span></p><p><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);"></span></p><p><br></p><p>如果它能把函数像变量一样赋值并传来传去，很多行为模式就没用了，比如<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;">Command、Strategy 等模式</span>。<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;">比如 C# 内置了 delegate/event，Observer 模式就没用了。</span></p><p><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;"></span><br></p><p>如果它的 style 不支持 class hierarchy，很多结构模式就没用了。</p><p><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">EventHandler/ConcreteEventHandler 这种 callback API 风格在现代语言里基本绝迹，C++ 有 std::function、C# 有 delegate、连 Java 8 都有了 Lambda，更别说动态语言了。<span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);">有的语言有 multiple dispatch，Vistor 模式就没用了。</span></span></p><p><span style="color: rgb(26, 26, 26);font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', 'PingFang SC', 'Microsoft YaHei', 'Source Han Sans SC', 'Noto Sans CJK SC', 'WenQuanYi Micro Hei', sans-serif;font-size: 15px;white-space: pre-wrap;background-color: rgb(255, 255, 255);"><br></span></p><p>ps：23种设计模式</p><p><br></p><p><span class="RichText CopyrightRichText-richText" itemprop="text"></span></p><p>创建型模式(五种)</p><ul class=" list-paddingleft-2"><li><p>工厂方法模式(Factory)：工厂创建对象（经典实现：很多框架初始化时都会创建一个工厂对象，用来加载资源）</p></li><li><p>抽象工厂模式(Abstractfactory)：抽象工厂实例创建对象，工厂可修改，灵活度高（经典实现：Struts2插件机制的核心实现就是BeanFactory这个抽象工厂。Spring IOC加载Bean，AOP创建Proxy）</p></li><li><p>单例模式(Singleton)：适用于只需要一个对象的情况（经典实现：Tomcat中StringManager的错误处理机制）</p></li><li><p>建造者模式(Builder)：一步一步创建一个复杂的对象（经典实现：MyBatis中的SQLSession就是结合了Configure，executor等对象，以此来实现SQLSession的复杂功能）</p></li><li><p>原型模式(Prototype)：复制对象，包括深度复制和浅度复制，深度复制重建引用对象，浅度复制不创建（经典实现：java序列化）</p><p><br></p></li></ul><p>结构型模式(七种)</p><ul class=" list-paddingleft-2"><li><p>适配器模式(Adapter)：通过实现接口，依赖注入，继承等方式为不相关的实体建立关系（经典实现：Tomcat新版本连接器Coyote，就是通过为Connector适配建立了ProtocolHandler与Tomcat组件Connector的关联关系）</p></li><li><p>装饰器模式(Decorator)：创建包装对象修饰扩展被包装对象的功能（经典实现：IO家族中BufferedXxx）</p></li><li><p>代理模式(Proxy)：通过添加中间代理的方式限制，过滤，修改被代理类的某些行为（经典实现：Spring AOP核心实现，DataSource中为Connection创建代理对象，改变close方法的行为，使其从开始的关闭连接变成将连接还回连接池）</p></li><li><p>外观模式(Facade)：通过外观的包装，使应用程序只能看到外观对象，而不会看到具体的细节对象。（经典实现：Tomcat中创建外观类包装StandardContext传给Wrapper，创建外观类包装Wrapper以ServletConfiguration的形式传给Servlet，以此来屏蔽不想让Servlet可见的那些Tomcat容器参数）</p></li><li><p>桥接模式(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化（经典实现：JDBC驱动）</p></li><li><p>组合模式(Composite)：部分与整体，常用于表示树形结构</p></li><li><p>享元模式(Flyweight)：维护资源集合（经典实现：数据库连接池，避免重新开启数据库链接的开销）</p><p><br></p></li></ul><p>行为型模式(十一种)</p><ul class=" list-paddingleft-2"><li><p>策略模式(Strategy)：定义多个不同的实现类，这些类实现公共接口，通过调用接口调用不同实例得到不同结果（经典实现：Spring中Bean的定义与注入，Controller，Servcie，repository三层架构中只依赖上一层接口）</p></li><li><p>模板方法模式(Template)：父类定义公共方法，不同子类重写父类抽象方法，得到不同结果（经典实现：Tomcat生命周期中的init，SpringIOC上层类加载具体子类指定的配置文件）</p></li><li><p>观察者模式(Observer)：目标方法被调用，通知所有观察者（经典实现：Tomcat生命周期事件监听，Spring BeanPostProcessor实现 ）</p></li><li><p>迭代子模式(Interator)：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。（经典实现：集合迭代器）</p></li><li><p>责任链模式(ChainOfResponsibility)：链式依赖，依次调用（经典实现：Tomcat Valve）</p></li><li><p>命令模式(Commond)：Action定义具体命令，拦截器Invocation回调执行命令（经典实现：Struts2）</p></li><li><p>备忘录模式(Memento)：建立原始对象副本，用于存储恢复原始对象数据</p></li><li><p>状态模式(Stage)：通过改变状态，改变行为（经典实现：切换装载着不同配置信息的配置文件对象）</p></li><li><p>访问者模式(Visitor)：结构与操作解耦。灵活的操作，放入固定的结构中执行（经典实现：在SpringAOP的实现过程中首先会有一个ProxyCreator去创建切入点，通知之类的，然后创建一个抽象工厂将这些参数对象传递给抽象工厂，抽象工厂调用createAopProxy(this)来创建对象，传入不同的抽象工厂创建出不同的实体对象）</p></li><li><p>中介者模式(Mediator)：MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者</p></li><li><p>解释器模式(Iterpreter)：定义分别定义 + - * / 非终结符，组合不同的非终结符定义不同的表达式，维护繁琐</p></li></ul><p><br></p><p><br></p><p><br></p>
                    
                </div>
                
                
                
            </div>
          
        <script type="text/javascript" src="../edu/tongji.js">
</script>
</body>
</html>
